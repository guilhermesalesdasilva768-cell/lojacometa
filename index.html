<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Cometa - Personaliza√ß√£o - Designer 3D</title>

    <!-- THREE / GLTF / Lottie -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.7.14/lottie.min.js"></script>

    <!-- Iconify -->
    <script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* ======================= */
        /*   FUNDO ESPA√áO PREMIUM  */
        /* ======================= */
        body {
            background: #0a0612;
            color: #fff;
            overflow-x: hidden;
            position: relative;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        /* Fundo cinematogr√°fico */
        body::before {
            content: "";
            position: fixed;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle at 50% 20%,
                rgba(122, 79, 255, 0.25) 0%,
                rgba(50, 0, 90, 0.5) 25%,
                rgba(0, 0, 0, 0.9) 70%
            );
            filter: blur(0px);
            z-index: -3;
        }

        /* Camada de estrelas */
        #starsLayer {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        .star {
            position: absolute;
            border-radius: 50%;
            opacity: 0.6;
            background: white;
            width: var(--size);
            height: var(--size);
            filter: blur(1px);
            animation: twinkle var(--duration) ease-in-out infinite alternate;
        }

        @keyframes twinkle {
            0% { opacity: 0.2; }
            100% { opacity: 0.8; }
        }

        /* Nebulosas */
        .nebula {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            filter: blur(160px);
            opacity: 0.06;
            animation: nebulaSlow 45s infinite ease-in-out;
            z-index: -1;
        }

        @keyframes nebulaSlow {
            0% { transform: translate(0,0) scale(1); }
            50% { transform: translate(40px,-30px) scale(1.1); }
            100% { transform: translate(0,0) scale(1); }
        }

        .nebula1 {
            top: 20%;
            left: 10%;
            width: 550px;
            height: 550px;
            background: radial-gradient(circle, rgba(160,110,255,0.5), transparent);
        }

        .nebula2 {
            bottom: 10%;
            right: 15%;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(110,50,200,0.5), transparent);
        }

        /* ================ */
        /*  MOBILE FIRST    */
        /* ================ */
        
         /* Header/Nav Mobile */
        nav {
            background: rgba(45, 45, 45, 0.98);
            backdrop-filter: blur(15px);
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 15px rgba(0,0,0,0.4);
            position: sticky;
            top: 0;
            z-index: 2000;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
       .logo {
    font-size: 1.4rem;
    font-weight: bold;

    /* Gradiente aplicado ao texto */
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    background-clip: text;
    -webkit-background-clip: text;

    color: transparent;
    -webkit-text-fill-color: transparent;
}

        
        .lottie-logo {
            width: 40px;
            height: 40px;
            display: inline-block;
            vertical-align: middle;
            overflow: visible;
            pointer-events: auto;
        }
        
        /* Menu Mobile */
        .mobile-menu-toggle {
            display: none;
            flex-direction: column;
            justify-content: space-between;
            width: 24px;
            height: 18px;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        
        .mobile-menu-toggle span {
            display: block;
            height: 2px;
            width: 100%;
            background-color: #fff;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        nav ul {
            display: flex;
            gap: 1.5rem;
            list-style: none;
        }
        
        nav a {
            color: #fff;
            text-decoration: none;
            font-weight: 500;
            transition: color .3s;
            font-size: 0.9rem;
        }
        
        nav a:hover {
            color: #667eea;
        }
        
        /* Hero Mobile */
        .hero {
            background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
            padding: 2.5rem 1rem;
            text-align: center;
        }
        
        .hero h1 {
            font-size: 1.6rem;
            margin-bottom: 1rem;
            line-height: 1.2;
        }
        
        .hero p {
            font-size: 1rem;
            opacity: 0.9;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        .section {
            margin: 2.5rem 0;
        }
        
        .section h2 {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        /* Designer 3D - Mobile Layout */
        .designer-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background: #2d2d2d;
            border-radius: 15px;
            padding: 1rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .canvas-container {
            background: #1a1a1a;
            border-radius: 10px;
            position: relative;
            height: 60vh;
            min-height: 400px;
            order: 1;
        }
        
        /* Ajuste m√≠nimo para telas muito pequenas: reduzimos a altura para caber melhor */
        @media (max-width: 420px) {
            .canvas-container { height: 52vh; min-height: 300px; }
        }

        #canvas3d {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            display: block;
        }
        
        .controls {
            order: 2;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            max-height: none;
            overflow-y: visible;
            padding-right: 0;
        }
        
        .control-group {
            background: #1a1a1a;
            padding: 1.2rem;
            border-radius: 10px;
        }
        
        .control-group h3 {
            margin-bottom: 1rem;
            color: #667eea;
            font-size: 1.1rem;
        }
        
        .shirt-types {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }
        
        .shirt-btn {
            padding: 0.8rem 0.5rem;
            background: #2d2d2d;
            border: 2px solid #444;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all .3s;
            font-size: 0.85rem;
        }
        
        .shirt-btn:hover {
            border-color: #667eea;
        }
        
        .shirt-btn.active {
            background: #667eea;
            border-color: #667eea;
        }
        
        .colors {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .color-btn {
            width: 100%;
            aspect-ratio: 1;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all .3s;
        }
        
        .color-btn:hover {
            transform: scale(1.1);
        }
        
        .color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }
        
        .color-input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .color-input-group input[type="text"] {
            flex: 1;
            padding: 0.6rem;
            background: #2d2d2d;
            border: 2px solid #444;
            color: #fff;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .color-input-group input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
            border: none;
            color: #fff;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all .3s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102,126,234,0.3);
        }
        
        .btn-secondary {
            background: #444;
        }
        
        .btn-secondary:hover {
            background: #555;
        }
        
        .side-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        /* √Årea de edi√ß√£o de design */
        .design-canvas-area {
            background: repeating-linear-gradient(45deg,#2a2a2a 0px,#2a2a2a 10px,#333 10px,#333 20px);
            border-radius: 10px;
            padding: 1rem;
            min-height: 200px;
            position: relative;
            overflow: hidden;
        }
        
        .design-canvas {
            width: 100%;
            height: 200px;
            background: white;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .design-element {
            position: absolute;
            cursor: grab;
            user-select: none;
            touch-action: none;
            transform-origin: top left;
        }
        
        .design-element.selected {
            outline: 2px dashed #667eea;
        }
        
        .design-element img {
            max-width: 100%;
            height: auto;
            display: block;
            pointer-events: none;
        }
        
        .design-element .text-content {
            font-size: 20px;
            font-weight: bold;
            white-space: nowrap;
            padding: 5px;
            pointer-events: none;
        }
        
        /* resize/rotate handles */
        .resize-handle, .rotate-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 3px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            z-index: 9999;
            display: none;
        }
        
        .design-element.selected .resize-handle,
        .design-element.selected .rotate-handle {
            display: block;
        }
        
        .resize-handle {
            right: -10px;
            bottom: -10px;
            cursor: se-resize;
        }
        
        .rotate-handle {
            right: -10px;
            top: -25px;
            cursor: grab;
            border-radius: 50%;
        }
        
        .element-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .element-controls .delete-btn {
            padding: 0.6rem;
            background: #c0392b;
            border: 2px solid #c0392b;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all .3s;
        }
        
        .upload-btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .upload-btn {
            padding: 0.8rem;
            background: #2d2d2d;
            border: 2px solid #667eea;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all .3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .upload-btn:hover {
            background: #667eea;
        }
        
        .upload-btn input {
            display: none;
        }
        
        /* Recent images gallery */
        .recent-images {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
        }
        
        .recent-thumb {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            overflow: hidden;
            background: #222;
            border: 2px solid #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .recent-thumb img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        
        .element-extra-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
            margin-top: 0.6rem;
        }
        
        .element-extra-controls label {
            font-size: 0.85rem;
            color: #ccc;
        }
        
        .element-extra-controls input[type="range"] {
            width: 100%;
        }
        
        .element-extra-controls input[type="number"] {
            width: 100%;
            padding: 0.4rem;
            border-radius: 6px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: #2d2d2d;
            padding: 1.5rem;
            border-radius: 15px;
            max-width: 90%;
            width: 400px;
        }
        
        .modal-content h3 {
            color: #667eea;
            margin-bottom: 1rem;
        }
        
        .modal-content input, .modal-content select {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            background: #1a1a1a;
            border: 2px solid #444;
            color: #fff;
            border-radius: 8px;
        }
        
        /* Produtos */
        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .product-card {
            background: #2d2d2d;
            border-radius: 15px;
            overflow: hidden;
            transition: all .3s;
            cursor: pointer;
        }
        
        .product-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(102,126,234,0.3);
        }
        
        .product-img {
            width: 100%;
            height: 150px;
            background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            overflow: hidden;
        }
        
        .product-img img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        .product-info {
            padding: 1rem;
        }
        
        .product-info h3 {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .product-info p {
            color: #aaa;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
        }
        
        .price {
            font-size: 1.2rem;
            color: #667eea;
            font-weight: bold;
        }
        
        .angle-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }
        
        .angle-btn {
            padding: 0.8rem 0.5rem;
            background: #2d2d2d;
            border: 2px solid #444;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all .3s;
            font-size: 0.85rem;
        }
        
        .angle-btn:hover, .angle-btn.active {
            border-color: #667eea;
            background: #667eea;
        }
        
        .small-note {
            font-size: 0.8rem;
            color: #bbb;
            margin-top: 0.5rem;
            line-height: 1.3;
        }
        
        /* Floating bubbles */
        .floating-bubbles {
            position: fixed;
            right: 15px;
            bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2200;
            align-items: flex-end;
            pointer-events: none;
        }
        
        .bubble {
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            color: #fff;
            text-decoration: none;
            transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
            border: 3px solid rgba(255,255,255,0.06);
            overflow: hidden;
            position: relative;
        }
        
        .bubble:hover {
            transform: translateY(-6px) scale(1.03);
            box-shadow: 0 14px 30px rgba(0,0,0,0.5);
        }
        
        .bubble.whatsapp {
            background: linear-gradient(135deg,#25D366 0%,#128C7E 100%);
        }
        
        .bubble.instagram {
            background: linear-gradient(135deg,#F58529 0%,#DD2A7B 50%,#833AB4 100%);
        }
        
        .bubble .label {
            position: absolute;
            right: 60px;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 0.85rem;
            opacity: 0;
            transform: translateX(6px);
            transition: opacity .12s ease, transform .12s ease;
            pointer-events: none;
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
        }
        
        .bubble:hover .label {
            opacity: 1;
            transform: translateX(0);
        }
        
        .bubble .iconify {
            width: 70%;
            height: 70%;
            display: block;
        }
        
        .bubble .iconify svg {
            width: 100%;
            height: 100%;
            display: block;
            fill: #fff;
        }
        
        .bubble svg {
            width: 24px;
            height: 24px;
            display: block;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 6px 18px rgba(0,0,0,0.35); transform: scale(1); }
            50% { box-shadow: 0 14px 30px rgba(0,0,0,0.5); transform: scale(1.04); }
            100% { box-shadow: 0 6px 18px rgba(0,0,0,0.35); transform: scale(1); }
        }
        
        .bubble.pulse {
            animation: pulse 3s ease-in-out infinite;
        }
        
        /* Additional styles for robust handles inside design-canvas */
        .design-element .handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #1a1a1a;
            border-radius: 3px;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 9999;
        }

        /* toque/gestos: garante que touch n√£o role a p√°gina ao interagir com elementos */
.design-element {
    touch-action: none;
    -ms-touch-action: none;
    cursor: grab;
    user-select: none;
    transform-origin: top left;
    pointer-events: auto;
}

/* handles precisam aceitar pointer events e n√£o bloquear o elemento pai */
.design-element .handle {
    touch-action: none;
    -ms-touch-action: none;
    pointer-events: auto;
}

/* √°rea maior para tocar nos handles em mobile */
@media (max-width: 900px) {
    .design-element .handle {
        width: 18px;
        height: 18px;
    }
}
        
        .design-element.selected .handle {
            display: block;
        }
        
        .handle.rotate {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #111;
            border: 3px solid #fff;
            cursor: grab;
        }
        /* Mobile Control Tabs */
.mobile-control-tabs {
    display: none;
    background: rgba(45, 45, 45, 0.98);
    backdrop-filter: blur(15px);
    border-top: 1px solid rgba(255,255,255,0.1);
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1500;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
}

.mobile-control-tabs::-webkit-scrollbar {
    display: none;
}

.mobile-tab {
    flex: 1;
    min-width: 80px;
    padding: 1rem 0.5rem;
    background: transparent;
    border: none;
    color: rgba(255,255,255,0.6);
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.3rem;
    border-bottom: 3px solid transparent;
}

.mobile-tab.active {
    color: #667eea;
    border-bottom-color: #667eea;
}

.mobile-tab .tab-icon {
    font-size: 1.3rem;
}

/* Mobile Panel */
.mobile-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #2d2d2d;
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    max-height: 60vh;
    overflow-y: auto;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1600;
    box-shadow: 0 -5px 30px rgba(0,0,0,0.5);
}

.mobile-panel.active {
    transform: translateY(0);
}

.mobile-panel-handle {
    width: 40px;
    height: 4px;
    background: rgba(255,255,255,0.3);
    border-radius: 2px;
    margin: 12px auto 8px;
}

.mobile-panel-content {
    padding: 0 1rem 1.5rem;
}
        
        .handle.tl { left: 0%; top: 0%; cursor: nwse-resize; }
        .handle.tr { left: 100%; top: 0%; cursor: nesw-resize; }
        .handle.bl { left: 0%; top: 100%; cursor: nesw-resize; }
        .handle.br { left: 100%; top: 100%; cursor: nwse-resize; }
        .handle.t { left: 50%; top: 0%; cursor: ns-resize; }
        .handle.b { left: 50%; top: 100%; cursor: ns-resize; }
        .handle.l { left: 0%; top: 50%; cursor: ew-resize; }
        .handle.r { left: 100%; top: 50%; cursor: ew-resize; }
        .handle.rotate { left: 100%; top: -18px; transform: translate(-50%, -50%); }
        
        /* Mobile-specific adjustments */
    /* Substitua o bloco @media (max-width: 768px) existente por este */
@media (max-width: 768px) {
    /* Navigation */
    .mobile-menu-toggle {
        display: flex;
    }

    nav ul {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        background: rgba(20, 20, 20, 0.98);
        backdrop-filter: blur(20px);
        flex-direction: column;
        padding: 5rem 2rem 2rem;
        gap: 1.5rem;
        display: none;
        align-items: center;
        justify-content: flex-start;
    }

    nav ul.active {
        display: flex;
    }

    nav ul li {
        width: 100%;
        text-align: center;
    }

    nav a {
        display: block;
        padding: 1rem;
        font-size: 1.1rem;
        border-radius: 10px;
    }

    /* Canvas: reduzir altura para evitar "quadrado gigante" no mobile */
    .canvas-container {
        height: 46vh; /* valor ajustado: ocupa menos da altura do ecr√£ no mobile */
        min-height: 260px;
        border-radius: 10px;
        padding: 0.5rem;
    }

    /* Mostrar controles (deixar abaixo do canvas, em vez de escond√™-los) */
    .controls {
        display: block !important;
        max-height: none;
        overflow-y: visible;
        padding: 0.8rem 1rem;
        margin-top: 0.75rem;
    }

    /* Esconder abas flutuantes / modal mobile que movem conte√∫do para "embaixo" */
    .mobile-control-tabs {
        display: none;
    }
    .mobile-panel {
        display: none !important;
    }

    /* Floating bubbles */
    .floating-bubbles {
        right: 10px;
        bottom: 90px;
    }
}

/* Floating quick FAB for opening editor on mobile */
.mobile-fab {
    position: fixed;
    right: 18px;
    bottom: 22px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: linear-gradient(135deg,#6b8cff 0%,#7a66ff 100%);
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2350;
    box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    border: none;
    cursor: pointer;
    font-size: 22px;
    pointer-events: auto;
}

/* Hide FAB on desktop */
@media (min-width: 769px) {
    .mobile-fab { display: none; }
}

/* Desktop adjustments */
        @media (min-width: 769px) {
            .designer-container {
                grid-template-columns: 1fr 400px;
                display: grid;
            }
            
            .canvas-container {
                order: 1;
            }
            
            .controls {
                order: 2;
                max-height: 600px;
                overflow-y: auto;
                padding-right: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Fundo espacial -->
    <div class="stars-layer" id="starsLayer"></div>
    <div class="nebula nebula1"></div>
    <div class="nebula nebula2"></div>
    
    <!-- Navega√ß√£o Mobile-Friendly -->
    <nav>
        <div class="brand">
            <div class="logo">Cometa - Personaliza√ß√£o</div>
            <div id="lottieLogo" class="lottie-logo" aria-hidden="true" title="Anima√ß√£o Cometa"></div>
        </div>
        
        <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Abrir menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
        
        <ul id="navMenu">
            <li><a href="#home">In√≠cio</a></li>
            <li><a href="#designer">Designer 3D</a></li>
            <li><a href="#produtos">Produtos</a></li>
            <li><a href="#contato">Contato</a></li>
        </ul>
    </nav>

    <script>
     // Menu mobile toggle
const mobileMenuToggle = document.getElementById('mobileMenuToggle');
const navMenu = document.getElementById('navMenu');

mobileMenuToggle.addEventListener('click', function() {
    navMenu.classList.toggle('active');
    mobileMenuToggle.classList.toggle('active');
});

document.querySelectorAll('#navMenu a').forEach(link => {
    link.addEventListener('click', () => {
        navMenu.classList.remove('active');
        mobileMenuToggle.classList.remove('active');
    });
});

// Mobile panel system
const mobileTabs = document.querySelectorAll('.mobile-tab');
const mobilePanel = document.getElementById('mobilePanel');
const mobilePanelContent = document.getElementById('mobilePanelContent');

const panelContents = {
    shirt: `

        <div class="control-group">
            <h3>Tipo de Camiseta</h3>
            <div class="shirt-types">
                <button class="shirt-btn active mobile-shirt-type" data-type="polo">Gola Polo</button>
                <button class="shirt-btn mobile-shirt-type" data-type="normal">Normal</button>
                <button class="shirt-btn mobile-shirt-type" data-type="long">Manga Longa</button>
            </div>
        </div>
    `,
    color: `
        <div class="control-group">
            <h3>Escolha a Cor</h3>
            <div class="colors">
                <button class="color-btn mobile-color" style="background:#8B0000;" data-color="#8B0000"></button>
                <button class="color-btn mobile-color" style="background:#FF0000;" data-color="#FF0000"></button>
                <button class="color-btn mobile-color" style="background:#FF8C00;" data-color="#FF8C00"></button>
                <button class="color-btn mobile-color" style="background:#FFB6C1;" data-color="#FFB6C1"></button>
                <button class="color-btn mobile-color" style="background:#FFFF00;" data-color="#FFFF00"></button>
                <button class="color-btn active mobile-color" style="background:#7FFF00;" data-color="#7FFF00"></button>
                <button class="color-btn mobile-color" style="background:#1E90FF;" data-color="#1E90FF"></button>
                <button class="color-btn mobile-color" style="background:#4169E1;" data-color="#4169E1"></button>
                <button class="color-btn mobile-color" style="background:#228B22;" data-color="#228B22"></button>
                <button class="color-btn mobile-color" style="background:#4B0082;" data-color="#4B0082"></button>
                <button class="color-btn mobile-color" style="background:#C0C0C0;" data-color="#C0C0C0"></button>
                <button class="color-btn mobile-color" style="background:#000000;" data-color="#000000"></button>
            </div>
        </div>
    `,
    design: `
        <div class="control-group">
            <h3>Adicionar</h3>
            <div class="upload-btn-group">
                <label class="upload-btn">
                    <span>üì∑ Imagem</span>
                    <input type="file" id="mobileImageUpload" accept="image/*">
                </label>
                <button class="upload-btn" id="mobileTextOpenBtn">
                    <span>üìù Texto</span>
                </button>
            </div>
        </div>
    `,
    view: `
        <div class="control-group">
            <h3>√Çngulo</h3>
            <div class="angle-buttons">
                <button class="angle-btn mobile-angle" data-angle="0">Frente</button>
                <button class="angle-btn mobile-angle" data-angle="90">Lado</button>
                <button class="angle-btn active mobile-angle" data-angle="180">Costas</button>
            </div>
        </div>
    `,
    actions: `
        <div class="control-group">
            <button class="btn" id="mobileApply" style="width:100%; margin-bottom:0.8rem;">‚úÖ Aplicar</button>
            <button class="btn" id="mobileDownload" style="width:100%; margin-bottom:0.8rem;">üì∏ Baixar</button>
            <button class="btn btn-secondary" id="mobileReset" style="width:100%;">üîÑ Resetar</button>
        </div>
    `
};

function loadMobilePanel(panelName) {
    if (!mobilePanel || !mobilePanelContent) return;
    mobilePanelContent.innerHTML = panelContents[panelName];
    
    if (panelName === 'shirt') {
        document.querySelectorAll('.mobile-shirt-type').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mobile-shirt-type').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentShirtType = this.dataset.type;
                createShirt();
                const mobileScaleFactor = (window.innerWidth <= 768) ? 0.6 : 1.0;
const appliedScale = MODEL_CONFIG.scale * mobileScaleFactor;
shirt.scale.set(appliedScale, appliedScale, appliedScale);
                mobilePanel.classList.remove('active');
            });
        });
    } else if (panelName === 'color') {
        document.querySelectorAll('.mobile-color').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mobile-color').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentColor = this.dataset.color;
                document.getElementById('customColorInput').value = currentColor;
                document.getElementById('colorPicker').value = currentColor;
                scheduleTextureUpdate();
                mobilePanel.classList.remove('active');
            });
        });
    } else if (panelName === 'view') {
        document.querySelectorAll('.mobile-angle').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mobile-angle').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                const angle = parseInt(this.dataset.angle, 10);
                if (shirt) shirt.rotation.y = (angle * Math.PI) / 180;
                mobilePanel.classList.remove('active');
            });
        });
    } else if (panelName === 'design') {
        const mobileFile = document.getElementById('mobileImageUpload');
        if (mobileFile) {
            mobileFile.addEventListener('change', handleImageUpload);
        }
        const mobileTextBtn = document.getElementById('mobileTextOpenBtn');
        if (mobileTextBtn) {
            mobileTextBtn.addEventListener('click', () => {
                openTextModal();
                mobilePanel.classList.remove('active');
            });
        }
    } else if (panelName === 'actions') {
        const applyBtn = document.getElementById('mobileApply');
        const downloadBtn = document.getElementById('mobileDownload');
        const resetBtn = document.getElementById('mobileReset');
        if (applyBtn) applyBtn.addEventListener('click', () => { applyDesignToShirt(); mobilePanel.classList.remove('active'); });
        if (downloadBtn) downloadBtn.addEventListener('click', () => { downloadImage(); mobilePanel.classList.remove('active'); });
        if (resetBtn) resetBtn.addEventListener('click', () => { resetDesign(); mobilePanel.classList.remove('active'); });
    }
}

mobileTabs.forEach(tab => {
    tab.addEventListener('click', function() {
        mobileTabs.forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        loadMobilePanel(this.dataset.panel);
        mobilePanel.classList.add('active');
    });
});

if (mobilePanel) {
    mobilePanel.addEventListener('click', function(e) {
        if (e.target === mobilePanel) {
            mobilePanel.classList.remove('active');
        }
    });
}

if (window.innerWidth <= 768 && mobilePanel && mobilePanelContent) {
    // load defaults lazily
    loadMobilePanel('shirt');
}
    </script>

    <div class="hero" id="home">
        <h1>Crie Sua Camiseta Personalizada</h1>
        <p>Voc√™ pensa a gente estampa, fa√ßa seu modelo inserindo a imagem na blusa, depois √© s√≥ mandar em nosso WhatsApp ou Instagram</p>
    </div>

    <div class="container">
        <section class="section" id="designer">
            <h2>Designer de Camisetas 3D</h2>
            <div class="designer-container">
                <div class="canvas-container">
                    <canvas id="canvas3d"></canvas>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <h3>Tipo de Camiseta</h3>
                        <div class="shirt-types">
                            <button class="shirt-btn active" data-type="polo">Gola Polo</button>
                            <button class="shirt-btn" data-type="normal">Normal</button>
                            <button class="shirt-btn" data-type="long">Manga Longa</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Cores</h3>
                        <div class="colors">
                            <button class="color-btn" style="background:#8B0000;" data-color="#8B0000"></button>
                            <button class="color-btn" style="background:#FF0000;" data-color="#FF0000"></button>
                            <button class="color-btn" style="background:#FF8C00;" data-color="#FF8C00"></button>
                            <button class="color-btn" style="background:#FFB6C1;" data-color="#FFB6C1"></button>
                            <button class="color-btn" style="background:#FFFF00;" data-color="#FFFF00"></button>
                            <button class="color-btn active" style="background:#7FFF00;" data-color="#7FFF00"></button>

                            <button class="color-btn" style="background:#1E90FF;" data-color="#1E90FF"></button>
                            <button class="color-btn" style="background:#4169E1;" data-color="#4169E1"></button>
                            <button class="color-btn" style="background:#228B22;" data-color="#228B22"></button>
                            <button class="color-btn" style="background:#4B0082;" data-color="#4B0082"></button>
                            <button class="color-btn" style="background:#C0C0C0;" data-color="#C0C0C0"></button>
                            <button class="color-btn" style="background:#000000;" data-color="#000000"></button>
                        </div>
                        <div class="color-input-group">
                            <span style="font-size:1.2rem;">‚öôÔ∏è</span>
                            <input type="text" id="customColorInput" placeholder="#FFFFFF" value="#7FFF00">
                            <input type="color" id="colorPicker" value="#7FFF00">
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Adicionar Design</h3>
                        <div class="side-selector">
                            <button class="shirt-btn active" id="frontSide">Frente</button>
                            <button class="shirt-btn" id="backSide">Costas</button>
                        </div>

                        <div class="upload-btn-group">
                            <label class="upload-btn">
                                <span>üì∑ Imagem</span>
                                <input type="file" id="imageUpload" accept="image/*">
                            </label>
                            <button class="upload-btn" onclick="openTextModal()">
                                <span>üìù Texto</span>
                            </button>
                        </div>

                        <div style="margin-top:.6rem;">
                            <label style="display:inline-flex; gap:.5rem; align-items:center; color:#ccc;">
                                <input type="checkbox" id="flipXCheckbox" title="Corrigir espelhamento (horizontal)">
                                <span style="font-size:0.9rem;">Corrigir espelhamento horizontal (flip X)</span>
                            </label>
                        </div>

                        <div class="small-note">Agora voc√™ pode ajustar imagens e textos puxando pelas al√ßas (cantos/lados) diretamente no quadro de edi√ß√£o. Clique para selecionar.</div>

                        <div class="recent-container" style="margin-top:.8rem;">
                            <h3 style="margin:.5rem 0 .6rem 0; color:#67a3ff; font-size:0.95rem;">Imagens recentes</h3>
                            <div id="recentImages" class="recent-images"></div>
                        </div>

                        <div class="design-canvas-area">
                            <div class="design-canvas" id="designCanvas"></div>
                            <div class="small-note">Clique na imagem/texto para selecionar, arraste para mover. Use as al√ßas em cada canto/lado para redimensionar e o c√≠rculo acima para girar.</div>
                        </div>

                        <div class="element-controls">
                            <button class="delete-btn" onclick="deleteSelected()">üóëÔ∏è Remover Selecionado</button>
                        </div>

                        <div class="element-extra-controls">
                            <label for="scaleRange">Escala:</label>
                            <input type="range" id="scaleRange" min="0.1" max="3" step="0.01" value="1" style="width:100%;">
                            <label for="textSizeInput" style="margin-top:8px;">Tamanho (px):</label>
                            <input type="number" id="textSizeInput" min="6" max="200" value="24">
                            <button class="btn btn-secondary" id="removeBgBtn" style="width:100%; margin-top:8px;" onclick="removeBackgroundSelected()" title="Remover fundo da imagem selecionada">ü™Ñ Remover Fundo</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>√Çngulos de Visualiza√ß√£o</h3>
                        <div class="angle-buttons">
                            <button class="angle-btn" data-angle="0">0¬∞</button>
                            <button class="angle-btn" data-angle="45">45¬∞</button>
                            <button class="angle-btn" data-angle="90">90¬∞</button>
                            <button class="angle-btn active" data-angle="180">180¬∞</button>
                            <button class="angle-btn" data-angle="270">270¬∞</button>
                            <button class="angle-btn" data-angle="315">315¬∞</button>
                        </div>
                        <div style="margin-top:0.8rem;">
                            <button class="btn" id="rotate360Btn" onclick="toggleContinuousRotation()">üîÑ Rota√ß√£o cont√≠nua</button>
                        </div>
                    </div>

                    <button class="btn" onclick="applyDesignToShirt()">‚úÖ Aplicar √† Camiseta</button>
                    <button class="btn" onclick="downloadImage()">üì∏ Baixar Imagem 3D</button>
                    <button class="btn btn-secondary" onclick="resetDesign()">üîÑ Resetar Tudo</button>
                </div>
            </div>
            <!-- Mobile Control Tabs -->
            <div class="mobile-control-tabs">
                <button class="mobile-tab active" data-panel="shirt">
                    <span class="tab-icon">üëï</span>
                    <span>Tipo</span>
                </button>
                <button class="mobile-tab" data-panel="color">
                    <span class="tab-icon">üé®</span>
                    <span>Cores</span>
                </button>
                <button class="mobile-tab" data-panel="design">
                    <span class="tab-icon">‚úèÔ∏è</span>
                    <span>Design</span>
                </button>
                <button class="mobile-tab" data-panel="view">
                    <span class="tab-icon">üëÅÔ∏è</span>
                    <span>Vista</span>
                </button>
                <button class="mobile-tab" data-panel="actions">
                    <span class="tab-icon">‚ö°</span>
                    <span>A√ß√µes</span>
                </button>
            </div>
            
            <!-- Mobile Panel -->
            <div class="mobile-panel" id="mobilePanel">
                <div class="mobile-panel-handle"></div>
                <div class="mobile-panel-content" id="mobilePanelContent"></div>
            </div>

            <!-- QUICK MOBILE FAB (abre painel de edi√ß√£o) -->
            <button id="mobileFab" class="mobile-fab" aria-label="Abrir editor">‚úé</button>

        </section>

        <section class="section" id="produtos">
            <h2>Outros Produtos</h2>
            <div class="products-grid">
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/blusa.png" alt="BLUSA ALGOD√ÉO TRADICIONAL">
                    </div>
                    <div class="product-info">
                        <h3>BLUSA ALGOD√ÉO TRADICIONAL</h3>
                        <p>V√°rias cores dispon√≠veis</p>
                        <div class="price">R$ 37,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/blusa4.png" alt="Copo Stanley">
                    </div>
                    <div class="product-info">
                        <h3> CROPPED OVERSIZED</h3>
                        <p>V√°rias cores dispon√≠veis</p>
                        <div class="price">R$ 39,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/blusa3.png" alt="GOLA POLO POLI√âSTER">
                    </div>
                    <div class="product-info">
                        <h3>GOLA POLO POLI√âSTER</h3>
                        <p>V√°rias cores dispon√≠veis</p>
                        <div class="price">R$ 39,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/blusa2.png" alt="BLUSA OVERSIZE">
                    </div>
                    <div class="product-info">
                        <h3>BLUSA OVERSIZE</h3>
                        <p>V√°rias cores dispon√≠veis</p>
                        <div class="price">R$ 44,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/caneca1.png" alt="CANECA BRANCA PORCELANA">
                    </div>
                    <div class="product-info">
                        <h3> CANECA BRANCA PORCELANA</h3>
                        <p></p>
                        <div class="price">R$ 26,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/caneca2.png" alt="CANECA MAGICA">
                    </div>
                    <div class="product-info">
                        <h3>CANECA MAGICA</h3>
                        <p></p>
                        <div class="price">R$ 29,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/caneca3.png" alt="CANECA FUNDO COLORIDO">
                    </div>
                    <div class="product-info">
                        <h3> CANECA FUNDO COLORIDO</h3>
                        <p></p>
                        <div class="price">R$ 29,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/caneca4.png" alt="CANECA COM FUNDO COLORIDO E COLHER">
                    </div>
                    <div class="product-info">
                        <h3> CANECA COM FUNDO COLORIDO E COLHER</h3>
                        <p></p>
                        <div class="price">R$ 29,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/garrafa.png" alt="GARRAFA SQUEZZE 500 ml">
                    </div>
                    <div class="product-info">
                        <h3>GARRAFA SQUEZZE 500 ml</h3>
                        <p></p>
                        <div class="price">R$ 29,99</div>
                    </div>
                </div>
                <div class="product-card">
                    <div class="product-img">
                        <img src="./assets/logo/ceramica.png" alt="CER√ÇMICA 20X20">
                    </div>
                    <div class="product-info">
                        <h3>CER√ÇMICA 20X20</h3>
                        <p></p>
                        <div class="price">R$ 19,99</div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <div class="modal" id="textModal">
        <div class="modal-content">
            <h3>Adicionar Texto</h3>
            <input type="text" id="textInput" placeholder="Digite seu texto" />
            <select id="fontSelect">
                <option value="Arial">Arial</option>
                <option value="Impact">Impact</option>
                <option value="Comic Sans MS">Comic Sans MS</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
            </select>
            <input type="color" id="textColorPicker" value="#000000" />
            <div class="modal-buttons" style="display:flex; gap:0.5rem;">
                <button class="btn" onclick="addText()">Adicionar</button>
                <button class="btn btn-secondary" onclick="closeTextModal()">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Floating bubbles -->
    <div class="floating-bubbles" aria-hidden="false">
        <a class="bubble whatsapp pulse" id="whatsappBubble"
            href="https://wa.me/5585981501747?text=Ol√°%20Cometa!%20Quero%20saber%20sobre%20personaliza√ß√£o."
            target="_blank" rel="noopener noreferrer" aria-label="Abrir WhatsApp" title="WhatsApp">
            <span class="iconify" data-icon="simple-icons:whatsapp" data-inline="false"></span>
            <span class="label">WhatsApp</span>
        </a>

        <a class="bubble instagram" id="instagramBubble"
            href="https://www.instagram.com/cometa_personalizacoes?utm_source=ig_web_button_share_sheet&igsh=ZDNlZDc0MzIxNw=="
            target="_blank" rel="noopener noreferrer" aria-label="Abrir Instagram" title="Instagram">
            <span class="iconify" data-icon="simple-icons:instagram" data-inline="false"></span>
            <span class="label">Instagram</span>
        </a>
    </div>

    <script>
        const SHIRT_MODELS = {
            polo: './assets/models/collar.glb',
            normal: './assets/models/normal.glb',
            long: './assets/models/long.glb'
        };
        const MODEL_CONFIG = { scale:2.0, position:{x:0,y:0,z:0}, rotation:{x:0,y:Math.PI,z:0} };

        let scene, camera, renderer, shirt;
        let currentShirtType = 'polo';
        let currentColor = '#7FFF00';
        let currentSide = 'front';
        let isDragging = false;
        let previousMousePosition = { x:0, y:0 };
        let gltfLoader = null;
        let loadedModels = {};
        let useGLBModels = true;

        // design elements: now each element has side, scaleX, scaleY
        let designElements = { front: [], back: [] };
        let selectedElement = null;
        let elementIdCounter = 0;

        let recentImages = [];
        const imageCache = new Map();

        let rafScheduled = false;
        function scheduleTextureUpdate() {
            if (rafScheduled) return;
            rafScheduled = true;
            requestAnimationFrame(async () => {
                await applyDesignToShirt();
                rafScheduled = false;
            });
        }

        let cameraTarget = new THREE.Vector3(0,0,0);
        let initialCameraZ = 5;
        let minCameraZ = 2;
        let maxCameraZ = 10;

        let continuousRotation = false;
        let rotationSpeed = Math.PI * 0.25;
        let lastAnimateTime = 0;

        // New flag to control horizontal flip to correct mirroring
        let textureFlipX = true; // default: correct the mirrored issue

        let resizing = null;
        let rotating = null;

        function safeDisposeTexture(tex) {
            try {
                if (tex && typeof tex.dispose === 'function') tex.dispose();
            } catch(e) { /* ignore */ }
        }

        function clearMaterialMaps(mat) {
            if (!mat) return;
            try {
                safeDisposeTexture(mat.normalMap);
                safeDisposeTexture(mat.displacementMap);
                safeDisposeTexture(mat.bumpMap);
                safeDisposeTexture(mat.roughnessMap);
                safeDisposeTexture(mat.metalnessMap);
                safeDisposeTexture(mat.aoMap);
                safeDisposeTexture(mat.emissiveMap);
                safeDisposeTexture(mat.alphaMap);
                mat.normalMap = null;
                mat.displacementMap = null;
                mat.bumpMap = null;
                mat.roughnessMap = null;
                mat.metalnessMap = null;
                mat.aoMap = null;
                mat.emissiveMap = null;
                mat.alphaMap = null;
                if (mat.normalScale && typeof mat.normalScale.set === 'function') mat.normalScale.set(0,0);
                if ('displacementScale' in mat) mat.displacementScale = 0;
                if ('roughness' in mat) mat.roughness = Math.max(0, mat.roughness ?? 1);
                if ('metalness' in mat) mat.metalness = Math.min(0, mat.metalness ?? 0);
                mat.needsUpdate = true;
            } catch (e) {
                console.warn('Erro ao limpar mapas do material', e);
            }
        }

        function init() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            cameraTarget.set(0,0,0);
            initialCameraZ = camera.position.z;
            minCameraZ = initialCameraZ * 0.4;
            maxCameraZ = initialCameraZ * 4;

            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true, 
                preserveDrawingBuffer: true,
                powerPreference: "high-performance",
                alpha: false,
                stencil: false,
                depth: true
            });

            // expose renderer to global for mobile tuning
            window.renderer = renderer;
            window.camera = camera;

            const pixelRatio = Math.min(window.devicePixelRatio, 3);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves

            if (THREE && THREE.sRGBEncoding) {
                renderer.outputEncoding = THREE.sRGBEncoding;
            }
            
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2); 
            keyLight.position.set(3, 4, 5); 
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 4096;
            keyLight.shadow.mapSize.height = 4096;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 20;
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6); 
            fillLight.position.set(-4, 2, -3); 
            scene.add(fillLight);

            const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
            rimLight.position.set(0, 3, -5);
            scene.add(rimLight);

            createShirt();

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel, { passive:false });

            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);

            document.getElementById('scaleRange').addEventListener('input', (e) => {
                if (!selectedElement) return;
                const v = parseFloat(e.target.value);
                // Update both scales to keep slider uniform-scaling behaviour
                selectedElement.scaleX = v;
                selectedElement.scaleY = v;
                renderDesignCanvas();
                scheduleTextureUpdate();
            });

            document.getElementById('textSizeInput').addEventListener('input', (e) => {
                if (!selectedElement) return;
                const v = parseInt(e.target.value, 10) || 12;
                if (selectedElement.type === 'text') {
                    selectedElement.data.size = v;
                    renderDesignCanvas();
                    scheduleTextureUpdate();
                }
            });

            // flip checkbox
            const flipCheckbox = document.getElementById('flipXCheckbox');
            if (flipCheckbox) {
                flipCheckbox.checked = textureFlipX;
                flipCheckbox.addEventListener('change', (e) => {
                    textureFlipX = !!e.target.checked;
                    scheduleTextureUpdate();
                });
            }

            animate();
            renderRecentImages();
            renderDesignCanvas(); // build editor UI
        }

        function fitCameraToObject(object, offset = 1.15) {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            cameraTarget.copy(center);

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim * offset / (2 * Math.tan(fov / 2)));
            if (cameraZ === 0 || !isFinite(cameraZ)) cameraZ = initialCameraZ;

            camera.position.set(center.x, center.y, center.z + cameraZ);
            camera.lookAt(center);
            camera.updateProjectionMatrix();

            initialCameraZ = camera.position.z;
            minCameraZ = Math.max(0.5, initialCameraZ * 0.35);
            maxCameraZ = initialCameraZ * 4;
        }

        function createShirt() {
            if (shirt) scene.remove(shirt);

            if (!useGLBModels) {
                createDefaultShirt();
                return;
            }

            const modelPath = SHIRT_MODELS[currentShirtType];

            if (loadedModels[currentShirtType]) {
                shirt = loadedModels[currentShirtType].clone();
                applyColorToModel(shirt, currentColor);
                const targetY = currentSide === 'front' ? 0 : Math.PI;
                shirt.rotation.set(MODEL_CONFIG.rotation.x, targetY, MODEL_CONFIG.rotation.z);
                shirt.position.set(MODEL_CONFIG.position.x, MODEL_CONFIG.position.y, MODEL_CONFIG.position.z);
                shirt.scale.set(MODEL_CONFIG.scale, MODEL_CONFIG.scale, MODEL_CONFIG.scale);
                shirt.traverse((child) => {
                    if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }
                });
                scene.add(shirt);
                fitCameraToObject(shirt, 1.15);
                applyDesignToShirt();
                return;
            }

            if (!gltfLoader && typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
            }

            if (modelPath && gltfLoader) {
                gltfLoader.load(
                    modelPath,
                    (gltf) => {
                        shirt = gltf.scene;
                        loadedModels[currentShirtType] = gltf.scene.clone();

                        applyColorToModel(shirt, currentColor);
                        const targetY = currentSide === 'front' ? 0 : Math.PI;
                        shirt.rotation.set(MODEL_CONFIG.rotation.x, targetY, MODEL_CONFIG.rotation.z);
                        shirt.position.set(MODEL_CONFIG.position.x, MODEL_CONFIG.position.y, MODEL_CONFIG.position.z);
                        shirt.scale.set(MODEL_CONFIG.scale, MODEL_CONFIG.scale, MODEL_CONFIG.scale);

                        shirt.traverse((child) => {
                            if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }
                        });

                        scene.add(shirt);
                        fitCameraToObject(shirt, 1.15);
                        applyDesignToShirt();
                    },
                    undefined,
                    (error) => {
                        console.error('Erro ao carregar modelo:', error);
                        createDefaultShirt();
                    }
                );
            } else {
                createDefaultShirt();
            }
        }

      function createDefaultShirt() {
    const geometry = new THREE.BoxGeometry(2, 2.5, 0.5);
    const material = new THREE.MeshPhongMaterial({ color: currentColor, flatShading:false });
    shirt = new THREE.Mesh(geometry, material);
    shirt.castShadow = true;
    shirt.rotation.y = (currentSide === 'front') ? 0 : Math.PI;
    const mobileScaleFactor = (window.innerWidth <= 768) ? 0.6 : 1.0;
    const appliedScale = MODEL_CONFIG.scale * mobileScaleFactor;
    shirt.scale.set(appliedScale, appliedScale, appliedScale);
    scene.add(shirt);
    fitCameraToObject(shirt, 1.1);
    applyDesignToShirt();
}

        function applyColorToModel(model, color) {
            if (!model || !model.traverse) {
                if (model && model.material) model.material.color.setHex(parseInt(color.replace('#','0x')));
                return;
            }
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => { if (mat.color) mat.color.setHex(parseInt(color.replace('#','0x'))); });
                    } else {
                        if (child.material.color) child.material.color.setHex(parseInt(color.replace('#','0x')));
                    }
                }
            });
        }

        function animate(time) {
            requestAnimationFrame(animate);
            if (!lastAnimateTime) lastAnimateTime = time;
            const dt = (time - lastAnimateTime) / 1000;
            lastAnimateTime = time;

            if (continuousRotation && shirt) {
                shirt.rotation.y += rotationSpeed * dt;
            }

            renderer.render(scene, camera);
        }

        // Add element: now includes side, scaleX, scaleY
        function addDesignElement(type, data) {
            const element = {
                id: elementIdCounter++,
                type: type,
                data: JSON.parse(JSON.stringify(data)), // clone to avoid shared references
                side: currentSide || 'front',
                x: 75,
                y: 75,
                scaleX: 1,
                scaleY: 1,
                rotation: 0
            };
            designElements[element.side].push(element);
            if (type === 'image' && data && data.src) {
                addToRecentImages(data.src);
            }
            renderDesignCanvas();
            scheduleTextureUpdate();
            selectElement(element.id);
        }

        function addDesignElementFromRecent(src) {
            const img = new Image();
            img.onload = () => {
                const maxDim = 300;
                let w = img.naturalWidth;
                let h = img.naturalHeight;
                const ratio = Math.min(maxDim / w, maxDim / h, 1);
                w = Math.round(w * ratio); h = Math.round(h * ratio);
                addDesignElement('image', { src, width: w, height: h });
            };
            img.src = src;
        }

        function addToRecentImages(src) {
            recentImages = recentImages.filter(s => s !== src);
            recentImages.unshift(src);
            if (recentImages.length > 12) recentImages.length = 12;
            renderRecentImages();
        }

        function renderRecentImages() {
            const el = document.getElementById('recentImages');
            if (!el) return;
            el.innerHTML = '';
            recentImages.forEach(src => {
                const div = document.createElement('div');
                div.className = 'recent-thumb';
                const img = document.createElement('img');
                img.src = src;
                div.appendChild(img);
                div.title = 'Adicionar ao design';
                div.addEventListener('click', () => addDesignElementFromRecent(src));
                el.appendChild(div);
            });
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const imgTemp = new Image();
                imgTemp.onload = () => {
                    const maxDim = 300;
                    let w = imgTemp.naturalWidth;
                    let h = imgTemp.naturalHeight;
                    const ratio = Math.min(maxDim / w, maxDim / h, 1);
                    w = Math.round(w * ratio); h = Math.round(h * ratio);
                    addDesignElement('image', { src: event.target.result, width: w, height: h });
                };
                imgTemp.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        }

        // renderDesignCanvas updated to use scaleX/scaleY and create handles per element
        function renderDesignCanvas() {
            const canvas = document.getElementById('designCanvas');
            canvas.innerHTML = '';

            const elements = designElements[currentSide];
            elements.forEach(element => {
                const div = document.createElement('div');
                div.className = 'design-element';
                div.dataset.id = element.id;
                const elW = (element.data.width || 100) * (element.scaleX || 1);
                const elH = (element.data.height || 100) * (element.scaleY || 1);

                div.style.left = element.x + 'px';
                div.style.top = element.y + 'px';
                div.style.width = elW + 'px';
                div.style.height = elH + 'px';
                div.style.transform = `rotate(${element.rotation}deg)`;
                div.style.position = 'absolute';
                div.style.display = 'inline-block';
                div.style.cursor = 'move';
                div.style.userSelect = 'none';
                div.style.boxSizing = 'border-box';

                const content = document.createElement('div');
                content.style.position = 'relative';
                content.style.display = 'inline-block';
                content.style.width = '100%';
                content.style.height = '100%';
                content.style.pointerEvents = 'none';

                if (element.type === 'image') {
                    const img = document.createElement('img');
                    img.src = element.data.src;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    img.draggable = false;
                    img.addEventListener('dragstart', ev => ev.preventDefault());
                    content.appendChild(img);
                } else if (element.type === 'text') {
                    const span = document.createElement('span');
                    span.className = 'text-content';
                    span.textContent = element.data.text;
                    span.style.fontFamily = element.data.font;
                    span.style.color = element.data.color;
                    span.style.fontSize = ((element.data.size || 24) * ((element.scaleX + element.scaleY)/2 || 1)) + 'px';
                    content.appendChild(span);
                }

                // create handles: corners & mid-sides
                const handles = ['tl','tr','bl','br','t','b','l','r'];
                handles.forEach(h => {
                    const hd = document.createElement('div');
                    hd.className = 'handle ' + h;
                    hd.dataset.handle = h;
                    hd.addEventListener('pointerdown', (ev) => {
                        ev.stopPropagation();
                        ev.preventDefault();
                        startResize(ev, element, h);
                    });
                    div.appendChild(hd);
                });

                // rotate
                const rh = document.createElement('div');
                rh.className = 'handle rotate';
                rh.title = 'Girar';
                rh.addEventListener('pointerdown', (ev) => {
                    ev.stopPropagation(); ev.preventDefault(); startRotate(ev, element);
                });
                rh.style.left = '100%';
                rh.style.top = '-18px';
                div.appendChild(rh);

                div.appendChild(content);

             div.addEventListener('pointerdown', (e) => { /* handler leve: o attachPointerHandlersToElement far√° sele√ß√£o e configura√ß√£o */ });
attachPointerHandlersToElement(div, element);

                if (selectedElement && selectedElement.id === element.id) {
                    div.classList.add('selected');
                }

                canvas.appendChild(div);
            });

            if (selectedElement) {
                updateElementControlsUI();
            } else {
                document.getElementById('scaleRange').value = 1;
                document.getElementById('textSizeInput').value = 24;
            }
        }

        function selectElement(id) {
            const elements = designElements[currentSide];
            selectedElement = elements.find(el => el.id === id) || null;
            renderDesignCanvas();
        }

       // --- BEGIN: Pointer-based drag + pinch/rotate gesture support ---

// estado de ponteiros ativo (id -> {x,y})
let activePointers = new Map();
// se arrastando com 1 ponteiro
let dragPointerId = null;
let draggedElement = null;
let dragOffset = { x:0, y:0 };

// estado de gesto (pinch/rotate)
let gestureState = null;

function attachPointerHandlersToElement(div, element) {
    // remove poss√≠veis listeners anteriores (n√£o obrigat√≥rio mas seguro)
    div.onpointerdown = null;

    div.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        e.stopPropagation();

        // foco / sele√ß√£o
        selectElement(element.id);

        // capture do ponteiro para este elemento (bom para touch)
        try { e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); } catch (err) {}

        // guarda ponteiro ativo
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (activePointers.size === 1) {
            // in√≠cio de arraste com um dedo
            dragPointerId = e.pointerId;
            draggedElement = element;
            const canvas = document.getElementById('designCanvas');
            const rect = canvas.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left - element.x;
            dragOffset.y = e.clientY - rect.top - element.y;

            // adiciona listeners globais (pode haver outros ponteiros)
            document.addEventListener('pointermove', onGlobalPointerMove, { passive:false });
            document.addEventListener('pointerup', onGlobalPointerUp);
            document.addEventListener('pointercancel', onGlobalPointerUp);
        } else if (activePointers.size === 2) {
            // in√≠cio de gesto pinch/rotate
            const pts = Array.from(activePointers.entries());
            const pA = pts[0][1], pB = pts[1][1];
            const centerX = (pA.x + pB.x) / 2;
            const centerY = (pA.y + pB.y) / 2;
            const dx = pB.x - pA.x, dy = pB.y - pA.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            // grava estado inicial do gesto baseado no elemento selecionado
            gestureState = {
                pointerIds: pts.map(t => t[0]),
                startDist: dist,
                startAngle: angle,
                startScaleX: element.scaleX || 1,
                startScaleY: element.scaleY || 1,
                startRotation: (element.rotation || 0) * Math.PI / 180,
                elementCenterOffset: null,
                targetElementId: element.id
            };

            // calcula centro do elemento em coordenadas do editor
            const canvas = document.getElementById('designCanvas');
            const rect = canvas.getBoundingClientRect();
            const elW = ((element.data.width || 100) * (element.scaleX || 1));
            const elH = ((element.data.height || 100) * (element.scaleY || 1));
            const elCenterX = rect.left + element.x + elW / 2;
            const elCenterY = rect.top + element.y + elH / 2;
            gestureState.elementCenterOffset = { x: elCenterX - centerX, y: elCenterY - centerY };
        }
    });
}

// handler global de movimento de pointers
function onGlobalPointerMove(e) {
    e.preventDefault();
    if (!activePointers.has(e.pointerId)) {
        // √†s vezes pointermove chega sem pointerdown registrado (safety)
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    } else {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }

    // se temos gesto de dois dedos ativo (gestureState) e os dois ponteiros ainda existem
    if (gestureState && activePointers.size >= 2) {
        const ids = gestureState.pointerIds;
        if (activePointers.has(ids[0]) && activePointers.has(ids[1])) {
            const p1 = activePointers.get(ids[0]);
            const p2 = activePointers.get(ids[1]);
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            const scaleRatio = dist / Math.max(gestureState.startDist, 0.0001);
            const newScaleX = Math.max(0.05, gestureState.startScaleX * scaleRatio);
            const newScaleY = Math.max(0.05, gestureState.startScaleY * scaleRatio);
            const deltaAngle = angle - gestureState.startAngle;
            const newRotation = (gestureState.startRotation + deltaAngle) * 180 / Math.PI;

            // aplica no elemento alvo (se ainda existir)
            const targetElements = designElements.front.concat(designElements.back);
            const target = targetElements.find(el => el.id === gestureState.targetElementId);
            if (target) {
                target.scaleX = newScaleX;
                target.scaleY = newScaleY;
                target.rotation = newRotation;
                // opcional: reposicionar para manter o centro do gesto (mais natural)
                // calcula novo centro do elemento e ajusta x/y
                const canvas = document.getElementById('designCanvas');
                const rect = canvas.getBoundingClientRect();
                const centerX_screen = (p1.x + p2.x) / 2;
                const centerY_screen = (p1.y + p2.y) / 2;
                const elCenterOffset = gestureState.elementCenterOffset || { x:0, y:0 };
                const desiredCenterX = centerX_screen + elCenterOffset.x;
                const desiredCenterY = centerY_screen + elCenterOffset.y;
                const elW = (target.data.width || 100) * (target.scaleX || 1);
                const elH = (target.data.height || 100) * (target.scaleY || 1);
                // novo x,y para que o centro fique no desiredCenter
                target.x = Math.max(0, Math.min(rect.width - elW, desiredCenterX - rect.left - elW / 2));
                target.y = Math.max(0, Math.min(rect.height - elH, desiredCenterY - rect.top - elH / 2));
            }

            renderDesignCanvas();
            scheduleTextureUpdate();
            return;
        }
    }

    // se estamos arrastando com 1 ponteiro
    if (dragPointerId !== null && activePointers.has(dragPointerId) && draggedElement) {
        const p = activePointers.get(dragPointerId);
        const canvas = document.getElementById('designCanvas');
        const rect = canvas.getBoundingClientRect();

        // atualiza posi√ß√£o com clamp nos limites
        let nx = p.x - rect.left - dragOffset.x;
        let ny = p.y - rect.top - dragOffset.y;

        const realW = ((draggedElement.data && draggedElement.data.width) || 50) * (draggedElement.scaleX || 1);
        const realH = ((draggedElement.data && draggedElement.data.height) || 20) * (draggedElement.scaleY || 1);

        nx = Math.max(0, Math.min(rect.width - realW, nx));
        ny = Math.max(0, Math.min(rect.height - realH, ny));

        draggedElement.x = nx;
        draggedElement.y = ny;

        renderDesignCanvas();
        scheduleTextureUpdate();
    }
}

// pointer up / cancel
function onGlobalPointerUp(e) {
    // remove capture se dispon√≠vel
    try { e.target.releasePointerCapture && e.target.releasePointerCapture(e.pointerId); } catch(err){}

    activePointers.delete(e.pointerId);

    // se o pointer que arrastava foi solto
    if (dragPointerId === e.pointerId) {
        dragPointerId = null;
        draggedElement = null;
        // remover listeners globais se n√£o houver ponteiros ativos
        if (activePointers.size === 0) {
            document.removeEventListener('pointermove', onGlobalPointerMove);
            document.removeEventListener('pointerup', onGlobalPointerUp);
            document.removeEventListener('pointercancel', onGlobalPointerUp);
        }
        scheduleTextureUpdate();
    }

    // se o gesto multi-touch terminou (menos de 2 pointers), encerra estado de gesto
    if (gestureState && activePointers.size < 2) {
        gestureState = null;
        // se ainda houver um ponteiro remanescente, podemos reiniciar um arraste com ele
        if (activePointers.size === 1) {
            const remaining = Array.from(activePointers.keys())[0];
            dragPointerId = remaining;
            // draggedElement permanece selecionado (j√° cadastrado em selectElement)
            const elements = designElements[currentSide];
            draggedElement = elements.find(el => el.id === selectedElement?.id) || selectedElement || null;
        }
    }
}

        // Enhanced resize: supports independent scaleX/scaleY by handle
        function startResize(ev, element, handle) {
            const canvas = document.getElementById('designCanvas');
            const rect = canvas.getBoundingClientRect();
            ev.target.setPointerCapture && ev.target.setPointerCapture(ev.pointerId);
            resizing = {
                element,
                handle,
                startX: ev.clientX,
                startY: ev.clientY,
                startW: (element.data.width || 100) * (element.scaleX || 1),
                startH: (element.data.height || 100) * (element.scaleY || 1),
                startScaleX: element.scaleX || 1,
                startScaleY: element.scaleY || 1,
                startElementX: element.x,
                startElementY: element.y,
                canvasRect: rect
            };
            document.addEventListener('pointermove', onResizeMove);
            document.addEventListener('pointerup', endResize);
        }

        function onResizeMove(ev) {
            if (!resizing) return;
            const { element, handle, startX, startY, startW, startH, startScaleX, startScaleY, startElementX, startElementY, canvasRect } = resizing;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            let newScaleX = startScaleX;
            let newScaleY = startScaleY;

            if (handle === 'br') {
                const newW = Math.max(10, startW + dx);
                const newH = Math.max(10, startH + dy);
                newScaleX = Math.max(0.05, newW / (element.data.width || 100));
                newScaleY = Math.max(0.05, newH / (element.data.height || 100));
            } else if (handle === 'bl') {
                const newW = Math.max(10, startW - dx);
                const newH = Math.max(10, startH + dy);
                newScaleX = Math.max(0.05, newW / (element.data.width || 100));
                newScaleY = Math.max(0.05, newH / (element.data.height || 100));
                element.x = startElementX + (startW - (element.data.width || 100) * newScaleX);
            } else if (handle === 'tr') {
                const newW = Math.max(10, startW + dx);
                const newH = Math.max(10, startH - dy);
                newScaleX = Math.max(0.05, newW / (element.data.width || 100));
                newScaleY = Math.max(0.05, newH / (element.data.height || 100));
                element.y = startElementY + (startH - (element.data.height || 100) * newScaleY);
            } else if (handle === 'tl') {
                const newW = Math.max(10, startW - dx);
                const newH = Math.max(10, startH - dy);
                newScaleX = Math.max(0.05, newW / (element.data.width || 100));
                newScaleY = Math.max(0.05, newH / (element.data.height || 100));
                element.x = startElementX + (startW - (element.data.width || 100) * newScaleX);
                element.y = startElementY + (startH - (element.data.height || 100) * newScaleY);
            } else if (handle === 't') {
                const newH = Math.max(10, startH - dy);
                newScaleY = Math.max(0.05, newH / (element.data.height || 100));
                element.y = startElementY + (startH - (element.data.height || 100) * newScaleY);
            } else if (handle === 'b') {
                const newH = Math.max(10, startH + dy);
                newScaleY = Math.max(0.05, newH / (element.data.height || 100));
            } else if (handle === 'l') {
                const newW = Math.max(10, startW - dx);
                newScaleX = Math.max(0.05, newW / (element.data.width || 100));
                element.x = startElementX + (startW - (element.data.width || 100) * newScaleX);
            } else if (handle === 'r') {
                const newW = Math.max(10, startW + dx);
                newScaleX = Math.max(0.05, newW / (element.data.width || 100));
            }

            // clamp inside editor
            const maxW = canvasRect.width;
            const maxH = canvasRect.height;
            element.scaleX = newScaleX;
            element.scaleY = newScaleY;
            element.x = Math.max(0, Math.min(element.x, maxW - ((element.data.width||100) * element.scaleX)));
            element.y = Math.max(0, Math.min(element.y, maxH - ((element.data.height||100) * element.scaleY)));

            // update UI slider to reflect uniform average scale (keeps old UI)
            const avgScale = (element.scaleX + element.scaleY) / 2;
            document.getElementById('scaleRange').value = avgScale;

            renderDesignCanvas();
            scheduleTextureUpdate();
        }

        function endResize(ev) {
            if (!resizing) return;
            document.removeEventListener('pointermove', onResizeMove);
            document.removeEventListener('pointerup', endResize);
            resizing = null;
            scheduleTextureUpdate();
        }

        // rotation handlers (uses center of element)
        function startRotate(ev, element) {
            const canvas = document.getElementById('designCanvas');
            const rect = canvas.getBoundingClientRect();

            const elX = rect.left + element.x;
            const elY = rect.top + element.y;
            const elW = (element.data.width || 100) * (element.scaleX || 1);
            const elH = (element.data.height || 100) * (element.scaleY || 1);
            const centerX = elX + elW / 2;
            const centerY = elY + elH / 2;

            rotating = {
                element,
                centerX,
                centerY,
                startAngle: (element.rotation || 0) * Math.PI / 180,
                startClientAngle: Math.atan2(ev.clientY - centerY, ev.clientX - centerX)
            };

            ev.target.setPointerCapture && ev.target.setPointerCapture(ev.pointerId);
            document.addEventListener('pointermove', onRotateMove);
            document.addEventListener('pointerup', endRotate);
        }

        function onRotateMove(ev) {
            if (!rotating) return;
            const { element, centerX, centerY, startAngle, startClientAngle } = rotating;
            const currentClientAngle = Math.atan2(ev.clientY - centerY, ev.clientX - centerX);
            const delta = currentClientAngle - startClientAngle;
            const newAngleRad = startAngle + delta;
            element.rotation = newAngleRad * 180 / Math.PI;
            renderDesignCanvas();
            scheduleTextureUpdate();
        }

        function endRotate(ev) {
            if (!rotating) return;
            document.removeEventListener('pointermove', onRotateMove);
            document.removeEventListener('pointerup', endRotate);
            rotating = null;
            scheduleTextureUpdate();
        }

        function updateElementControlsUI() {
            const scaleRange = document.getElementById('scaleRange');
            const textSizeInput = document.getElementById('textSizeInput');
            const removeBgBtn = document.getElementById('removeBgBtn');

            if (!selectedElement) {
                scaleRange.value = 1;
                textSizeInput.value = 24;
                removeBgBtn.style.display = 'none';
                return;
            }

            const avgScale = ((selectedElement.scaleX || 1) + (selectedElement.scaleY || 1)) / 2;
            scaleRange.value = avgScale;

            if (selectedElement.type === 'text') {
                textSizeInput.value = selectedElement.data.size || 24;
                removeBgBtn.style.display = 'none';
            } else if (selectedElement.type === 'image') {
                textSizeInput.value = Math.round(avgScale * 100);
                removeBgBtn.style.display = 'inline-block';
            } else {
                removeBgBtn.style.display = 'none';
            }
        }

        function deleteSelected() {
            if (!selectedElement) return;
            const elements = designElements[currentSide];
            const index = elements.findIndex(el => el.id === selectedElement.id);
            if (index > -1) {
                elements.splice(index, 1);
                selectedElement = null;
                renderDesignCanvas();
                scheduleTextureUpdate();
            }
        }

        async function removeBackgroundSelected() {
            if (!selectedElement || selectedElement.type !== 'image') return;
            try {
                const src = selectedElement.data.src;
                const img = await loadImagePromise(src);
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
                const data = imageData.data;

                function sampleCorner(x, y, w, h) {
                    const samples = [];
                    const stepX = Math.max(1, Math.floor(w / 8));
                    const stepY = Math.max(1, Math.floor(h / 8));
                    for (let i = 0; i < 5; i++) {
                        const sx = Math.min(w-1, Math.max(0, Math.floor(x + (i*stepX) % w)));
                        const sy = Math.min(h-1, Math.max(0, Math.floor(y + (i*stepY) % h)));
                        const idx = (sy * w + sx) * 4;
                        samples.push([data[idx], data[idx+1], data[idx+2]]);
                    }
                    return samples;
                }
                const w = canvas.width, h = canvas.height;
                const samples = [
                    ...sampleCorner(0,0,w,h),
                    ...sampleCorner(w-1,0,w,h),
                    ...sampleCorner(0,h-1,w,h),
                    ...sampleCorner(w-1,h-1,w,h)
                ];
                const avg = samples.reduce((acc, c) => { acc[0]+=c[0]; acc[1]+=c[1]; acc[2]+=c[2]; return acc; }, [0,0,0]).map(v=>Math.round(v/samples.length));

                const threshold = 65;

                function colorDist(r,g,b) {
                    const dr = r - avg[0];
                    const dg = g - avg[1];
                    const db = b - avg[2];
                    return Math.sqrt(dr*dr + dg*dg + db*db);
                }

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const dist = colorDist(r,g,b);
                    if (dist < threshold) {
                        data[i+3] = 0;
                    }
                }
                ctx.putImageData(imageData, 0, 0);

                const newSrc = canvas.toDataURL('image/png');
                selectedElement.data.src = newSrc;
                selectedElement.data.width = Math.round(canvas.width * Math.min(300/canvas.width,1));
                selectedElement.data.height = Math.round(canvas.height * Math.min(300/canvas.height,1));

                addToRecentImages(newSrc);

                renderDesignCanvas();
                scheduleTextureUpdate();

                alert('Remo√ß√£o de fundo aplicada (m√©todo simples). Se n√£o ficar perfeito, use imagens com fundo uniforme ou me envie para solu√ß√£o avan√ßada.');
            } catch (err) {
                console.error('Erro removendo fundo:', err);
                alert('N√£o foi poss√≠vel remover o fundo desta imagem.');
            }
        }

        function loadImagePromise(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                // Se for data:URI, n√£o tentamos setar crossOrigin
                if (!src.startsWith('data:')) {
                    img.crossOrigin = 'anonymous';
                }
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // applyDesignToShirt with horizontal flip support (fixes mirrored result)
async function applyDesignToShirt() {
    if (!shirt) return;
    const designCanvasEl = document.getElementById('designCanvas');
    const designRect = designCanvasEl.getBoundingClientRect();
    if (designRect.width === 0 || designRect.height === 0) return;

    // choose safe size
    const maxTextureSize = (renderer && renderer.capabilities && renderer.capabilities.maxTextureSize) ? renderer.capabilities.maxTextureSize : 8192;
    const preferredBase = 2048; // safe default
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    const targetW = Math.min(Math.round(preferredBase * DPR), maxTextureSize);
    const targetH = Math.min(Math.round(preferredBase * DPR), maxTextureSize);

    const canvas = document.createElement('canvas');
    canvas.width = targetW;
    canvas.height = targetH;
    const ctx = canvas.getContext('2d', { alpha: true });
    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch (e){}

    // fill background with shirt color to simulate print area (optional)
    ctx.fillStyle = currentColor || '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw front and back side side-by-side (keeps compatibility with your UV layout)
    const bothElements = [
        { side: 'front', elements: designElements.front },
        { side: 'back', elements: designElements.back }
    ];

    const allElements = [...designElements.front, ...designElements.back];
    const loadPromises = allElements.map(el => {
        if (el.type === 'image') {
            const src = el.data.src;
            if (imageCache.has(src)) {
                const item = imageCache.get(src);
                if (item.loaded) return Promise.resolve({ id: el.id, img: item.img });
                return new Promise(resolve => item.onloadCallbacks.push(resolve));
            } else {
                const img = new Image();
                if (!src.startsWith('data:')) img.crossOrigin = 'anonymous';
                const cacheItem = { img:null, loaded:false, onloadCallbacks: [] };
                imageCache.set(src, cacheItem);
                return new Promise(resolve => {
                    img.onload = () => {
                        cacheItem.loaded = true; cacheItem.img = img;
                        resolve({ id: el.id, img });
                        cacheItem.onloadCallbacks.forEach(cb => cb({ id: el.id, img }));
                        cacheItem.onloadCallbacks = [];
                    };
                    img.onerror = () => {
                        cacheItem.loaded = true; cacheItem.img = null;
                        resolve({ id: el.id, img: null });
                        cacheItem.onloadCallbacks.forEach(cb => cb({ id: el.id, img: null }));
                        cacheItem.onloadCallbacks = [];
                    };
                    img.src = src;
                });
            }
        }
        return Promise.resolve({ id: el.id, img: null, text: true });
    });

    const loaded = await Promise.all(loadPromises);
    const imgMap = new Map();
    loaded.forEach(r => { if (r && r.img) imgMap.set(r.id, r.img); });

    const finalCanvasW = canvas.width;
    const finalCanvasH = canvas.height;
    const sxHalf = (finalCanvasW / 2) / designRect.width;
    const sy = finalCanvasH / designRect.height;
    const sAvg = (sxHalf + sy) / 2;

    bothElements.forEach(bucket => {
        // >>> ALTERA√á√ÉO CR√çTICA: algumas UVs t√™m a frente no lado direito do atlas.
        // desenhar FRONT na metade DIREITA e BACK na metade ESQUERDA corrige o espelhamento observado.
        const offsetX = (bucket.side === 'front') ? (finalCanvasW / 2) : 0;

        const elements = bucket.elements || [];
        elements.forEach(element => {
            ctx.save();

            const elW_editor = (element.data.width || 100) * (element.scaleX || element.scale || 1);
            const elH_editor = (element.data.height || 100) * (element.scaleY || element.scale || 1);

            const centerX_editor = element.x + elW_editor / 2;
            const centerY_editor = element.y + elH_editor / 2;

            const centerX_tex = offsetX + centerX_editor * sxHalf;
            const centerY_tex = centerY_editor * sy;

            const elW_tex = elW_editor * sxHalf;
            const elH_tex = elH_editor * sy;

            ctx.translate(centerX_tex, centerY_tex);
            ctx.rotate((element.rotation || 0) * Math.PI / 180);

            if (element.type === 'image') {
                const img = imgMap.get(element.id);
                if (img) {
                    try {
                        ctx.drawImage(img, -elW_tex / 2, -elH_tex / 2, elW_tex, elH_tex);
                    } catch (e) {
                        console.warn('Erro desenhando imagem no canvas de textura', e);
                    }
                }
            } else if (element.type === 'text') {
                const fontSize_editor = element.data.size || 24;
                const fontSize_tex = Math.max(6, Math.round(fontSize_editor * sAvg));
                ctx.font = `${fontSize_tex}px ${element.data.font || 'Arial'}`;
                ctx.fillStyle = element.data.color || '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(element.data.text, 0, 0);
            }

            ctx.restore();
        });
    });

    // Create THREE texture
    const texture = new THREE.CanvasTexture(canvas);
    texture.flipY = false;
    if (THREE && THREE.sRGBEncoding) texture.encoding = THREE.sRGBEncoding;

    if (textureFlipX) {
        texture.repeat.set(-1, 1);
        texture.offset.x = 1;
    } else {
        texture.repeat.set(1,1);
        texture.offset.x = 0;
    }

    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    texture.generateMipmaps = false;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : (renderer.capabilities.maxAnisotropy || 1);
    texture.anisotropy = Math.min(maxAniso || 1, 16);
    texture.needsUpdate = true;

    // Substitui materiais (mantive sua l√≥gica)
    if (shirt && shirt.traverse) {
        shirt.traverse((child) => {
            if (child.isMesh) {
                try { if (child.material && child.material.map) child.material.map.dispose(); } catch(e){}
                child.material = new THREE.MeshStandardMaterial({
                    map: texture,
                    color: 0xffffff,
                    roughness: 0.65,
                    metalness: 0.02,
                    transparent: true,
                    side: THREE.FrontSide
                });
                child.material.needsUpdate = true;
            }
        });
    } else if (shirt && shirt.material) {
        try { if (shirt.material.map) shirt.material.map.dispose(); } catch(e){}
        shirt.material = new THREE.MeshStandardMaterial({
            map: texture, color:0xffffff, roughness:0.7, metalness:0.1, transparent: true
        });
        shirt.material.needsUpdate = true;
    }
}

        async function downloadImage() {
            await applyDesignToShirt();
            await new Promise(r => setTimeout(r, 100));
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = 'minha-camiseta-3d.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        function resetDesign() {
            designElements = { front: [], back: [] };
            selectedElement = null;
            currentColor = '#7FFF00';
            currentSide = 'front';
            document.getElementById('customColorInput').value = '#7FFF00';
            document.getElementById('colorPicker').value = '#7FFF00';
            document.getElementById('frontSide').click();
            renderDesignCanvas();
            createShirt();
        }

        window.addEventListener('resize', () => {
            const container = document.querySelector('.canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            // Atualiza pixelRatio caso a tela mude de DPR (opcional)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2.5));
            if (shirt) fitCameraToObject(shirt, 1.15);
        });

        function toggleContinuousRotation() {
            continuousRotation = !continuousRotation;
            const btn = document.getElementById('rotate360Btn');
            if (continuousRotation) {
                btn.textContent = '‚è∏Ô∏è Parar rota√ß√£o';
                btn.style.background = 'linear-gradient(135deg,#ffb347 0%,#ffcc33 100%)';
            } else {
                btn.textContent = 'üîÑ Rota√ß√£o cont√≠nua';
                btn.style.background = '';
            }
        }

        document.querySelectorAll('.shirt-btn[data-type]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.shirt-btn[data-type]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentShirtType = btn.dataset.type;
                createShirt();
            });
        });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentColor = btn.dataset.color;
                document.getElementById('customColorInput').value = currentColor;
                document.getElementById('colorPicker').value = currentColor;
                scheduleTextureUpdate();
            });
        });

        document.getElementById('customColorInput').addEventListener('input', (e) => {
            let value = e.target.value;
            if (value.startsWith('#') && (value.length === 7 || value.length === 4)) {
                currentColor = value; document.getElementById('colorPicker').value = value; scheduleTextureUpdate();
            }
        });
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            currentColor = e.target.value; document.getElementById('customColorInput').value = currentColor; scheduleTextureUpdate();
        });

        document.querySelectorAll('.angle-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.angle-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const angle = parseInt(btn.dataset.angle, 10);
                if (shirt) shirt.rotation.y = (angle * Math.PI) / 180;
            });
        });

        document.getElementById('frontSide').addEventListener('click', () => {
            document.getElementById('frontSide').classList.add('active');
            document.getElementById('backSide').classList.remove('active');
            currentSide = 'front';
            if (shirt) shirt.rotation.y = 0;
            renderDesignCanvas();
            scheduleTextureUpdate();
        });

        document.getElementById('backSide').addEventListener('click', () => {
            document.getElementById('backSide').classList.add('active');
            document.getElementById('frontSide').classList.remove('active');
            currentSide = 'back';
            if (shirt) shirt.rotation.y = Math.PI;
            renderDesignCanvas();
            scheduleTextureUpdate();
        });

        function onMouseDown(e) { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; }
        function onMouseMove(e) {
            if (!isDragging || !shirt) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            shirt.rotation.y += deltaX * 0.01;
            shirt.rotation.x += deltaY * 0.01;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }
        function onMouseUp() { isDragging = false; }

        function onWheel(e) {
            e.preventDefault();
            const delta = e.deltaY * 0.01;
            camera.position.z = Math.max(minCameraZ, Math.min(maxCameraZ, camera.position.z + delta));
            camera.lookAt(cameraTarget);
        }

        function openTextModal() { document.getElementById('textModal').classList.add('active'); }
        function closeTextModal() { document.getElementById('textModal').classList.remove('active'); }

        function addText() {
            const text = document.getElementById('textInput').value.trim();
            const font = document.getElementById('fontSelect').value;
            const color = document.getElementById('textColorPicker').value;
            if (!text) return;
            addDesignElement('text', { text, font, color, size: 24, width: 200, height: 60 });
            document.getElementById('textInput').value = '';
            closeTextModal();
        }

        init();
        renderDesignCanvas();

        // Mobile behavior: toggle editor modal, adjust renderer DPR and canvas size on mobile
(function() {
  const isMobile = window.matchMedia('(max-width:900px)').matches || /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  // create FAB
  function createFAB() {
    let fab = document.querySelector('.mobile-fab');
    if (!fab) {
      fab = document.createElement('button');
      fab.className = 'mobile-fab';
      fab.title = 'Abrir editor';
      fab.innerHTML = '‚úé'; // √≠cone simples
      document.body.appendChild(fab);
    }
    return fab;
  }

  // create modal skeleton if not exists
  function ensureModal() {
    let modal = document.getElementById('editorModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'editorModal';
      modal.innerHTML = `
        <div class="modal-handle" aria-hidden="true"></div>
        <div class="modal-body">
          <div id="modalControlsContainer"></div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    return modal;
  }

  // move controls content into modal (clone) to preserve desktop layout
  function moveControlsToModal() {
    const modal = ensureModal();
    const container = modal.querySelector('#modalControlsContainer');
    container.innerHTML = '';

    // Clone the relevant control area (you can adjust selector to pick what you want)
    const controlGroups = document.querySelectorAll('.controls > .control-group');
    controlGroups.forEach(node => {
      const clone = node.cloneNode(true);
      // make buttons touch friendly
      clone.querySelectorAll('button, .btn').forEach(b => { b.classList.add('mobile-control'); b.style.minWidth = '92px'; });
      container.appendChild(clone);
    });

    // Also append the "recent images" and the editor canvas container
    const designCanvas = document.getElementById('designCanvas');
    if (!designCanvas) {
      const designCanvasWrap = document.createElement('div');
      designCanvasWrap.innerHTML = `<div id="designCanvas" class="design-canvas" aria-label="Editor"></div>`;
      container.appendChild(designCanvasWrap);
    } else {
      // If it exists in DOM elsewhere, move it into the modal
      if (designCanvas.parentElement !== container) container.appendChild(designCanvas);
    }
  }

  // toggle modal show/close
  function toggleModal(show) {
    const modal = ensureModal();
    if (show) {
      modal.classList.add('show');
      modal.setAttribute('aria-hidden','false');
      document.body.style.overflow = 'hidden';
    } else {
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden','true');
      document.body.style.overflow = '';
    }
  }

  // adjust canvas heights and renderer DPR if renderer is global
  function tuneRendererForMobile() {
    try {
      if (isMobile && window.renderer) {
        window.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.2));
      } else if (window.renderer) {
        window.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2.5));
      }
    } catch (e) {
      console.warn('tuneRendererForMobile:', e);
    }
  }

  // ensure canvas container height equals viewport on orientation change
  function adjustCanvasHeight() {
    const canvasContainer = document.querySelector('.canvas-container');
    if (!canvasContainer) return;
    if (isMobile) {
      // altura fixa razo√°vel para mobile (mant√©m espa√ßo abaixo para controles)
      canvasContainer.style.height = '46vh';
    } else {
      canvasContainer.style.height = '';
    }
    try {
      if (window.renderer && window.camera) {
        const rect = canvasContainer.getBoundingClientRect();
        window.renderer.setSize(rect.width, rect.height, false);
        window.camera.aspect = rect.width / rect.height;
        window.camera.updateProjectionMatrix();
      }
    } catch (e) { /* ignore */ }
  }

  // init mobile adjustments
    function initMobileUX() {
    // N√£o movemos controles para modal no mobile ‚Äî deixamos o fluxo natural (canvas > controls).
    tuneRendererForMobile();
    adjustCanvasHeight();

    // For√ßa exibir o painel de controles (caso alguma regra CSS anterior o esconda)
    const ctrl = document.querySelector('.controls');
    if (ctrl) {
      ctrl.style.display = 'block';
    }

    // Reajusta em mudan√ßas de orienta√ß√£o/tamanho
    window.addEventListener('orientationchange', () => {
      setTimeout(() => { adjustCanvasHeight(); }, 250);
    });
    window.addEventListener('resize', () => adjustCanvasHeight());
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => initMobileUX());
  } else initMobileUX();
})();
    </script>

    <script>
/* Estrelas minimalistas */
  function generateMinimalStars() {
            const layer = document.getElementById("starsLayer");
            layer.innerHTML = "";

            const starCount = 140;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement("div");
                star.classList.add("star");

                star.style.setProperty("--size", (Math.random() * 1.5 + 0.5) + "px");
                star.style.setProperty("--duration", (3 + Math.random() * 3) + "s");
                star.style.top = Math.random() * 100 + "%";
                star.style.left = Math.random() * 100 + "%";

                layer.appendChild(star);
            }
        }

        generateMinimalStars();

        /* Cometas rar√≠ssimos */
        function spawnRareComet() {
            const body = document.body;
            const comet = document.createElement("div");

            comet.classList.add("comet", "slow");

            comet.style.top = (-10 - Math.random() * 10) + "vh";
            comet.style.left = (80 + Math.random() * 40) + "vw";

            body.appendChild(comet);

            setTimeout(() => comet.remove(), 9000);

            const next = 10000 + Math.random() * 15000;
            setTimeout(spawnRareComet, next);
        }

        spawnRareComet();
    </script>

    <!-- SAFE mobile-FAB wiring (does not depend on early DOM queries) -->
    <script>
      // This script ensures the quick FAB opens the mobile-panel safely (scoped, after DOM ready).
      document.addEventListener('DOMContentLoaded', () => {
        const mobileFab = document.getElementById('mobileFab');
        if (!mobileFab) return;

        // Reuse panelContents defined earlier and create a safe loader that scopes its queries
        function openMobilePanel(panelName) {
          const panelEl = document.getElementById('mobilePanel');
          const contentEl = document.getElementById('mobilePanelContent');
          if (!panelEl || !contentEl) return;
          contentEl.innerHTML = panelContents[panelName] || '';

          // Scoped helper to add handlers (works even if earlier loadMobilePanel didn't run)
          if (panelName === 'shirt') {
            contentEl.querySelectorAll('.mobile-shirt-type').forEach(btn => {
              btn.addEventListener('click', function() {
                contentEl.querySelectorAll('.mobile-shirt-type').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentShirtType = this.dataset.type;
                createShirt();
                panelEl.classList.remove('active');
              });
            });
          }

          if (panelName === 'color') {
            contentEl.querySelectorAll('.mobile-color').forEach(btn => {
              btn.addEventListener('click', function() {
                contentEl.querySelectorAll('.mobile-color').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentColor = this.dataset.color;
                const ci = document.getElementById('customColorInput');
                const cp = document.getElementById('colorPicker');
                if (ci) ci.value = currentColor;
                if (cp) cp.value = currentColor;
                scheduleTextureUpdate();
                panelEl.classList.remove('active');
              });
            });
          }

          if (panelName === 'view') {
            contentEl.querySelectorAll('.mobile-angle').forEach(btn => {
              btn.addEventListener('click', function() {
                contentEl.querySelectorAll('.mobile-angle').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                const angle = parseInt(this.dataset.angle, 10);
                if (shirt) shirt.rotation.y = (angle * Math.PI) / 180;
                panelEl.classList.remove('active');
              });
            });
          }

          if (panelName === 'design') {
            const mobileFile = contentEl.querySelector('#mobileImageUpload');
            if (mobileFile) mobileFile.addEventListener('change', handleImageUpload);
            const mobileTextBtn = contentEl.querySelector('#mobileTextOpenBtn');
            if (mobileTextBtn) mobileTextBtn.addEventListener('click', () => {
              openTextModal();
              panelEl.classList.remove('active');
            });
          }

          if (panelName === 'actions') {
            const applyBtn = contentEl.querySelector('#mobileApply');
            const downloadBtn = contentEl.querySelector('#mobileDownload');
            const resetBtn = contentEl.querySelector('#mobileReset');
            if (applyBtn) applyBtn.addEventListener('click', () => { applyDesignToShirt(); panelEl.classList.remove('active'); });
            if (downloadBtn) downloadBtn.addEventListener('click', () => { downloadImage(); panelEl.classList.remove('active'); });
            if (resetBtn) resetBtn.addEventListener('click', () => { resetDesign(); panelEl.classList.remove('active'); });
          }

          // show panel
          panelEl.classList.add('active');
        }

        // Open the shirt tab by default when tapping the FAB
        mobileFab.addEventListener('click', (ev) => {
          ev.preventDefault();
          openMobilePanel('shirt');
        });
      });
    </script>

</body>
</html>
